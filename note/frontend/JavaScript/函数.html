<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.53">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>函数 | 麦林斯的笔记</title><meta name="description" content=" ">
    <link rel="preload" href="/assets/style.e06f2840.css" as="style" /><link rel="stylesheet" href="/assets/style.e06f2840.css" />
    <link rel="modulepreload" href="/assets/app.629164ab.js"><link rel="modulepreload" href="/assets/函数.html.dadc451a.js"><link rel="modulepreload" href="/assets/函数.html.33a603a1.js"><link rel="prefetch" href="/assets/index.html.5c635ae7.js" as="script" /><link rel="prefetch" href="/assets/CSS.html.505949a5.js" as="script" /><link rel="prefetch" href="/assets/Flex.html.f9ce955c.js" as="script" /><link rel="prefetch" href="/assets/H5C3.html.192d2f5a.js" as="script" /><link rel="prefetch" href="/assets/HTML.html.b4cea3bb.js" as="script" /><link rel="prefetch" href="/assets/HTTP.html.c3fe2e38.js" as="script" /><link rel="prefetch" href="/assets/jQuery.html.bf8848ac.js" as="script" /><link rel="prefetch" href="/assets/Uni-app.html.41cd190d.js" as="script" /><link rel="prefetch" href="/assets/微信公众号.html.3d1b656d.js" as="script" /><link rel="prefetch" href="/assets/微信小程序.html.2f9dd982.js" as="script" /><link rel="prefetch" href="/assets/DOM_BOM.html.b44d8de6.js" as="script" /><link rel="prefetch" href="/assets/ES6.html.d87efb9a.js" as="script" /><link rel="prefetch" href="/assets/事件循环.html.f3a153c9.js" as="script" /><link rel="prefetch" href="/assets/作用域.html.b838662b.js" as="script" /><link rel="prefetch" href="/assets/函数进阶.html.bd71e450.js" as="script" /><link rel="prefetch" href="/assets/原型链.html.aa56778f.js" as="script" /><link rel="prefetch" href="/assets/对象.html.848419be.js" as="script" /><link rel="prefetch" href="/assets/常见知识点.html.7b440930.js" as="script" /><link rel="prefetch" href="/assets/异步.html.97414490.js" as="script" /><link rel="prefetch" href="/assets/数据劫持.html.29a61289.js" as="script" /><link rel="prefetch" href="/assets/数据类型.html.fd70a65b.js" as="script" /><link rel="prefetch" href="/assets/数组.html.8928426a.js" as="script" /><link rel="prefetch" href="/assets/正则.html.9296e488.js" as="script" /><link rel="prefetch" href="/assets/运算符.html.f0f67980.js" as="script" /><link rel="prefetch" href="/assets/面向对象.html.3133ae42.js" as="script" /><link rel="prefetch" href="/assets/Element-UI.html.95e79459.js" as="script" /><link rel="prefetch" href="/assets/TyprScript.html.b8770427.js" as="script" /><link rel="prefetch" href="/assets/Vue-Cli.html.746d3038.js" as="script" /><link rel="prefetch" href="/assets/Vue2.X基础.html.7ec47f93.js" as="script" /><link rel="prefetch" href="/assets/Vue3.X基础.html.42ca937a.js" as="script" /><link rel="prefetch" href="/assets/VueX.html.e26d5e55.js" as="script" /><link rel="prefetch" href="/assets/Vue路由.html.c4ef3cad.js" as="script" /><link rel="prefetch" href="/assets/Vue项目开发.html.2cb3bca5.js" as="script" /><link rel="prefetch" href="/assets/Webpack.html.ce8d9aa5.js" as="script" /><link rel="prefetch" href="/assets/源码探索.html.12687c91.js" as="script" /><link rel="prefetch" href="/assets/生命周期.html.66726976.js" as="script" /><link rel="prefetch" href="/assets/组件通信.html.a43067eb.js" as="script" /><link rel="prefetch" href="/assets/配置开发环境.html.81034c7c.js" as="script" /><link rel="prefetch" href="/assets/404.html.c3e557d0.js" as="script" /><link rel="prefetch" href="/assets/index.html.e423ae14.js" as="script" /><link rel="prefetch" href="/assets/CSS.html.e0420ec6.js" as="script" /><link rel="prefetch" href="/assets/Flex.html.25c90ebb.js" as="script" /><link rel="prefetch" href="/assets/H5C3.html.5360943d.js" as="script" /><link rel="prefetch" href="/assets/HTML.html.7c7062a8.js" as="script" /><link rel="prefetch" href="/assets/HTTP.html.03d3679c.js" as="script" /><link rel="prefetch" href="/assets/jQuery.html.8d930cd6.js" as="script" /><link rel="prefetch" href="/assets/Uni-app.html.43a849c6.js" as="script" /><link rel="prefetch" href="/assets/微信公众号.html.b4ccf3be.js" as="script" /><link rel="prefetch" href="/assets/微信小程序.html.cc232e89.js" as="script" /><link rel="prefetch" href="/assets/DOM_BOM.html.93fe6026.js" as="script" /><link rel="prefetch" href="/assets/ES6.html.aca5e16b.js" as="script" /><link rel="prefetch" href="/assets/事件循环.html.bbee7911.js" as="script" /><link rel="prefetch" href="/assets/作用域.html.1126575d.js" as="script" /><link rel="prefetch" href="/assets/函数进阶.html.734a1d2f.js" as="script" /><link rel="prefetch" href="/assets/原型链.html.9ae959c8.js" as="script" /><link rel="prefetch" href="/assets/对象.html.6ae523b1.js" as="script" /><link rel="prefetch" href="/assets/常见知识点.html.4d8c1c09.js" as="script" /><link rel="prefetch" href="/assets/异步.html.cefc848b.js" as="script" /><link rel="prefetch" href="/assets/数据劫持.html.448a19e0.js" as="script" /><link rel="prefetch" href="/assets/数据类型.html.098d1a1f.js" as="script" /><link rel="prefetch" href="/assets/数组.html.8822e395.js" as="script" /><link rel="prefetch" href="/assets/正则.html.f8230894.js" as="script" /><link rel="prefetch" href="/assets/运算符.html.f03d92db.js" as="script" /><link rel="prefetch" href="/assets/面向对象.html.87672bf0.js" as="script" /><link rel="prefetch" href="/assets/Element-UI.html.1d83b2b9.js" as="script" /><link rel="prefetch" href="/assets/TyprScript.html.23b68bb0.js" as="script" /><link rel="prefetch" href="/assets/Vue-Cli.html.50b491d2.js" as="script" /><link rel="prefetch" href="/assets/Vue2.X基础.html.8f7c6fd6.js" as="script" /><link rel="prefetch" href="/assets/Vue3.X基础.html.6762cacf.js" as="script" /><link rel="prefetch" href="/assets/VueX.html.42261fc4.js" as="script" /><link rel="prefetch" href="/assets/Vue路由.html.2695bb69.js" as="script" /><link rel="prefetch" href="/assets/Vue项目开发.html.4d305771.js" as="script" /><link rel="prefetch" href="/assets/Webpack.html.1583d384.js" as="script" /><link rel="prefetch" href="/assets/源码探索.html.4402ade9.js" as="script" /><link rel="prefetch" href="/assets/生命周期.html.f7a43877.js" as="script" /><link rel="prefetch" href="/assets/组件通信.html.4a1cd2e0.js" as="script" /><link rel="prefetch" href="/assets/配置开发环境.html.b6fc84ec.js" as="script" /><link rel="prefetch" href="/assets/404.html.09c13488.js" as="script" />
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">麦林斯的笔记</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/note/frontend/base/HTTP.md" class="" aria-label="前端笔记"><!--[--><!--]--> 前端笔记 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/note/frontend/base/HTTP.md" class="" aria-label="前端笔记"><!--[--><!--]--> 前端笔记 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">前端基础 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/note/frontend/base/HTTP.html" class="sidebar-item" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/HTML.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/H5C3.html" class="sidebar-item" aria-label="H5C3"><!--[--><!--]--> H5C3 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/Flex.html" class="sidebar-item" aria-label="Flex"><!--[--><!--]--> Flex <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/jQuery.html" class="sidebar-item" aria-label="jQuery"><!--[--><!--]--> jQuery <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" class="sidebar-item" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/Uni-app.html" class="sidebar-item" aria-label="Uni-app"><!--[--><!--]--> Uni-app <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">javaScript <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/note/frontend/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html" class="sidebar-item" aria-label="数据类型"><!--[--><!--]--> 数据类型 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E8%BF%90%E7%AE%97%E7%AC%A6.html" class="sidebar-item" aria-label="运算符"><!--[--><!--]--> 运算符 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E6%95%B0%E7%BB%84.html" class="sidebar-item" aria-label="数组"><!--[--><!--]--> 数组 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/note/frontend/JavaScript/%E5%87%BD%E6%95%B0.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="函数"><!--[--><!--]--> 函数 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F.html" class="sidebar-item" aria-label="作用域"><!--[--><!--]--> 作用域 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%AF%B9%E8%B1%A1.html" class="sidebar-item" aria-label="对象"><!--[--><!--]--> 对象 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE.html" class="sidebar-item" aria-label="原型链"><!--[--><!--]--> 原型链 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/DOM&amp;BOM.html" class="sidebar-item" aria-label="DOM &amp; BOM"><!--[--><!--]--> DOM &amp; BOM <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%BC%82%E6%AD%A5.html" class="sidebar-item" aria-label="异步"><!--[--><!--]--> 异步 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html" class="sidebar-item" aria-label="事件循环"><!--[--><!--]--> 事件循环 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html" class="sidebar-item" aria-label="面向对象"><!--[--><!--]--> 面向对象 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6.html" class="sidebar-item" aria-label="函数进阶"><!--[--><!--]--> 函数进阶 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E6%AD%A3%E5%88%99.html" class="sidebar-item" aria-label="正则"><!--[--><!--]--> 正则 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81.html" class="sidebar-item" aria-label="数据劫持"><!--[--><!--]--> 数据劫持 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/ES6.html" class="sidebar-item" aria-label="ES6"><!--[--><!--]--> ES6 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html" class="sidebar-item" aria-label="常见知识点"><!--[--><!--]--> 常见知识点 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">Vue <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/note/frontend/Vue/%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html" class="sidebar-item" aria-label="配置开发环境"><!--[--><!--]--> 配置开发环境 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Vue-Cli.html" class="sidebar-item" aria-label="Vue-Cli"><!--[--><!--]--> Vue-Cli <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" class="sidebar-item" aria-label="生命周期"><!--[--><!--]--> 生命周期 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html" class="sidebar-item" aria-label="组件通信"><!--[--><!--]--> 组件通信 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Vue2.X%E5%9F%BA%E7%A1%80.html" class="sidebar-item" aria-label="Vue2.X 基础"><!--[--><!--]--> Vue2.X 基础 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Vue3.X%E5%9F%BA%E7%A1%80.html" class="sidebar-item" aria-label="Vue3.X 基础"><!--[--><!--]--> Vue3.X 基础 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Vue%E8%B7%AF%E7%94%B1.html" class="sidebar-item" aria-label="Vue路由"><!--[--><!--]--> Vue路由 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/VueX.html" class="sidebar-item" aria-label="Vuex"><!--[--><!--]--> Vuex <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2.html" class="sidebar-item" aria-label="源码探索"><!--[--><!--]--> 源码探索 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/TyprScript.html" class="sidebar-item" aria-label="TyprScript"><!--[--><!--]--> TyprScript <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Element-UI.html" class="sidebar-item" aria-label="Element-UI"><!--[--><!--]--> Element-UI <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91.html" class="sidebar-item" aria-label="Vue项目开发"><!--[--><!--]--> Vue项目开发 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h1><h1 id="javascript函数、回调函数、柯里化" tabindex="-1"><a class="header-anchor" href="#javascript函数、回调函数、柯里化" aria-hidden="true">#</a> <strong>JavaScript函数、回调函数、柯里化</strong></h1><h1 id="一、函数" tabindex="-1"><a class="header-anchor" href="#一、函数" aria-hidden="true">#</a> <strong>一、函数</strong></h1><p><strong><strong>函数的概念</strong></strong></p><blockquote><p>函数：就是封装了一段可被重复调用执行的代码块，通过此代码块可以实现大量代码的重复使用。</p></blockquote><p>在js里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。</p><p>虽然for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用JS中的函数。</p><p><strong><strong>函数的使用</strong></strong></p><blockquote><p>函数在使用时分为两步：声明函数和调用函数</p></blockquote><p><strong><strong>声明函数</strong></strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//声明函数
function 函数名(){
    //函数体代码
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>function是声明函数的关键字，必须小写</li><li>由于函数一般是为了实现某个功能才定义的，所有通常我们将函数名命名为动词，比如getSum</li></ul><p><strong><strong>调用函数</strong></strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//调用函数
函数名();//通过调用函数名来执行函数体代码

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>调用的时候千万不要忘记添加小括号</li><li>口诀：函数不调用，自己不执行</li></ul><p>注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码</p><p><strong><strong>函数的封装</strong></strong></p><ul><li>函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口</li><li>简单理解：封装类似于将电脑配件整合组装到机箱中（类似快递打包）</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 函数使用分为两步： 声明函数 和 调用函数
// 1、声明函数
    // function 函数名(){
    //     // 函数体
    // }
    function sayHi() {
        console.log(&#39;hi~~&#39;);
    }
// (1)function 声明函数的关键字  全部小写
// (2)函数是做某件事情，函数名一般是动词 sayHi
// (3)函数不调用自己不执行
// 2、调用函数
// 函数名();
    sayHi();
// 调用函数的时候千万不要忘记加小括号

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>案例</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 利用函数计算1~100之间的累加和
// 1、声明函数
function getSum() {
    var sum = 0;
    for (var i = 1; i &lt;= 100; i++) {
        sum += i;
    }
    console.log(sum);
}
// 2、调用函数
getSum();

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><strong>函数的参数</strong></strong></p><p><strong>形参和实参</strong></p><ul><li>形参：形式上的参数，函数定义的时候传递的参数，当时并不知道是什么</li><li>实参：实际上的参数，函数调用的时候传递的参数，实参是传递给形参的</li></ul><blockquote><p>在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时，同样也需要传递相应的参数，这些参数被称为实参。</p></blockquote><p>参数的作用：在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去</p><p><strong>按值传递、按引用传递</strong></p><ul><li>按值传递：按值传递是一种比较容易理解又使用比较广泛的传参方式，这种方式在传参的时候，在内存中会直接把实参的值复制一份再把副本传递给形参，对于形参的修改并不会影响到实参</li><li>按引用传递：由于在js中，引用类型在内存中分两部分存放，实际的值存放在堆中，在栈中会存放引用类型位于堆中的地址，而我们平时操作的，都是通过栈中的地址对对象进行操作的，那么如果使用按引用传递，就意味着操作的是同一个地址，对于形参的修改就会影响到实参。</li></ul><p><strong>js中的传参策略</strong></p><p>那么按照上面的分析，可能会有人认为，在js中，对于值类型是按值传递，对于引用类型是按引用传递，然而，这是<strong>错误</strong>的。事实上，在js中，不管对于值类型还是引用类类型，都是按值传递的，区别在于，对于值类型，传参发生时，<strong>复制的是类型本身的值</strong>，而对于引用类型，<strong>复制的是类型的地址</strong>。我们来看下面这段代码，可以用来否定引用类型是按引用传参这个观点。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var testC={};
function testObject(example){
    example={b:1};
}
testObject(testC)
console.log(testC);               //输出{}，实参并没有改变

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面的代码我们可以看出，如果是按引用传参，那么直接修改形参，是会对实参造成影响的，但是我们发现事实上并没有，为了方便理解，下面给出JavaScript中值类型和引用类型进行传参时在内存中的实际复制情况：</p><p>值类型</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOcAAADcCAIAAAAEKyEZAAAHY0lEQVR4nO3dPVLjSACG4dbWHMRUQTK1JxgSp3uKMQmEcICpcsIBxuFOAnsJCE0CR5gEV+Gb9AYqNEL9o1a7jfXJ7xNMgce2bOl1u23LorLWGkDKX4e+AcBgVAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VAs9VDtGVVV5T3FPP05Uq8RaS7iGauXwVw2NMRVrYVQ6Q2mzddqns8modoyqqnJ7ZUs1mCGMnbWWXjuodnQibxdU7z79Ro3Ll0PfAPjVbxe03zRoTxuOHGPtuLTTrH9oZgj1vwy0hmrHJj6aMtzWqFZDM2EwDLdUq6Izxz1yvBobu7rUZmpLuIaxdvw679cyrzV8NgZFjLXQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQw7FnBuPoLxnKHnaDanNw6JNBij/OmSFAT+FqQ8dlL7sUHLnBMwQ3waEHCj6SQwf33s3Ig/kY1s8uBlfbOfxve/16AzWBv685+Q3TXlGR8xjfakxcROJqnN7aLjZD8K4a+6798/jX4Ha7zbhU5Qid2JF3VNr0Fqd31Nsy1boHX49vv+bXIksv7v7+/uTk5P7+ftClOg/LlEesd/2kLCuU7GZ1XlXV+Wrj3rbRru0MZapNH2XdLTpO2+324uIio91QHN7XAyFZN3mzOq++m/8eLrMuLWVYte5I2R4eel94NQdrV3ncZ7frsh//cliK0FUFBtrT62f7fH2acgPkRR7xkZHAO2q6o0XoV+8p8/n8APc/2Ww2e3t7c+/poDUz9Of4UrweLs23n68ZF9yf4sstPK81rQHVWtsMG82tbx7uzSmN9Xpd9r5lWy6XnTu4WCzW6/VsNktcCbZ112z4GT97XnvkynyiG9owNjphkLBYLJbLZbzXmu37Y2D1Q8K9iAn8kXKEFN4Pwdtle3yNnG1s0ntts763aUP3tx1oeqzeRfSSWOeJSlbrfe1lPo64zfyh4HKLm8/ni8ViaK+NTlWhXDqrZeTrZFR2esimbJvmf+sfJrBtEguL3+XekbV3Ec7N2KzOz25e/vx++WD//Sd05k9VfOnDrs4dTZvJnPuc2P51ArE2erdB5/kk5eklb7umP34Ou/4PXC1MwiS1938Tp7CT2TTFq2Wv8GLiGybxvTCkYK9w6KFa6KFa6KFa6OHVWA4+dD2snapVeb+wuIndnX0r/iDfaYaQ8tZj7wcQwFDDxlpvcO6JnY+F3DNMb/TFZ8r5jm78DO1GQ3spHMNwm/jBrxcP6bhh1YZ2U3J3iPaOr+6vE948KfsTevfiSH9IH+3rivxXY/GtEtkXbHorsTZ0+tQ+Za/7y+Zd/5jlvBpL3+3QO4qk7z6ipf0dnvav7n81sr+B46/w8er9OrrfLZ/YOs+pNvGtg84UojOLmOp3pEJ3yjvohmQt+fHq9mv9LcfXn+bmu3NMhAkp8MQRefYR/e7NdruNfJGhd/93G/guQ/uHlJsRWas963CzOj/7/ePPTuHJF9yP4svNOR5Ch3t6c/7O4CGRrMk99ozpu4PNc1R8FtE+Q6bX3y/fvp7lX37shlXrfS6LT91Mq+l2viVu/B5lHL/DfSPF/dm9SN68Nmqzuv11+SN8PA99O3021mwn70y3HWtTcyffkRvUbvsOhp6UOnc8NNbu4vHq7Obvh+7kYGKCrwiivJeNXFvK4iZw7JnQevBeJLKs+PVHbsPDpQkdeSblavek+KIHX118tZrAnCz/Bh6C99gzdbI2bRuYwDiacv4U3vNHks1YREHFFz14htDcjtD/ejMdupTxqHu9u7sbdHgE+/FoUe4Z0l/RRq7/w0mb1e0vY15uzt6v4erxw+Kkt0IH+9cG5R17xqR9s7zza0ZVtvOJ1+n1s70O3Z4pJWv4ZrnX09PTbDYL9RoZPusfev838Y2CyWya4g8bqh1sekPXvhVfY3xvDHqoFnqoFnqoFnp45yvH+PejmDaqzcF7CIMUf5AzQ4AeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUeqoUevlmeg+MhHBaHB4QeZgjQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQQ7XQ8z9dm8qEMdGmQAAAAABJRU5ErkJggg==" alt="Untitled"></p><p>引用类型</p><p><img src="/assets/Untitled1.1c255227.png" alt="Untitled"></p><p>对于js中的变量，值类型存放在栈中，引用类型的地址存放在栈中，对应的值存放在堆中。当传参发生的时候，值类型会直接将栈中的值进行复制，形参和实参此时实际上是两个完全不相干的变量。对于引用类型，传参发生时，会将实参变量位于栈中的地址进行复制，此时栈中会有两个指向同一个堆地址的指针。</p><p>我们可以把ECMAScript函数的参数想象成局部变量。在向参数传递基本类型的值时，被传递的值被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素）。在向参数传递引用类型时，会把这个值在内存中的地址（指针）复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 1、函数可以重复相同的代码
function cook() {
    console.log(&#39;酸辣土豆丝&#39;);
}
cook();
cook();
// 2、我们可以利用函数的参数实现函数重复不同的代码
function 函数名(形参1， 形参2...) { //在声明函数的小括号里面是 形参 （形式上的参数）

}
函数名(实参1， 实参2...); //在函数调用的小括号里面是实参（实际的参数）
// 3、形参和实参的执行过程
function cook(aru) { //形参是接受实参的 aru=&#39;酸辣土豆丝&#39; 形参类似于一个变量
    console.log(aru);
}
cook(&#39;酸辣土豆丝&#39;);
cook(&#39;大肘子&#39;);
// 4、函数的参数可以有，也可以没有 个数不限

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 1、利用函数求任意两个数的和
function getSum(num1, num2) {
    console.log(num1 + num2);
}
getSum(1, 3);
getSum(3, 8);
// 2、利用函数求任意两个数之间的和
function getSums(start, end) {
    var sum = 0;
    for (var i = start; i &lt;= end; i++) {
        sum += i;
    }
    console.log(sum);
}
getSums(1, 100);
getSums(1, 10);
// 3、注意点
// (1)多个参数之间用逗号隔开
// (2)形参可以看做是不用声明的变量

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>函数形参和实参合数不匹配问题</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function sum(num1, num2) {
    console.log(num1 + num2);
}
sum(100,200);            //形参和实参个数相等，输出正确结果
sum(100,400,500,700);    //实参个数多于形参，只取到形参的个数
sum(200);                //实参个数少于形参，多的形参定义为undefined，结果为NaN

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：在JavaScript中，形参的默认值是undefined</p><p><strong>小结</strong></p><ul><li>函数可以带参数也可以不带参数</li><li>声明函数的时候，函数名括号里面的是形参，形参的默认值是undefined</li><li>调用函数的时候，函数名括号里面的是实参</li><li>多个参数中间用逗号分隔</li><li>形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配</li></ul><p><strong><strong>函数的返回值</strong></strong></p><p><strong>return语句</strong></p><p>有的时候，我们会希望函数将值返回给调用者，此时通过使用return语句就可以实现。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 1.函数是做某件事或者实现某种功能
function cook(aru) {
    console.log(aru);
}
cook(&#39;大肘子&#39;);
// 2.函数的返回值格式
function 函数名() {
    return 需要返回的结果;
}
函数名();
// (1)我们函数只是实现某种功能，最终的结果需要返回给函数的调用者函数名() 通过return实现的
// (2)只要函数遇到return 就把后面的结果 返回给函数的调用者 函数名()=return后面的结果
// 3.代码验证
function getResult() {
    return 666;
}
getResult(); //getResult()=666
console.log(getResult());

function cook(aru) {
    return aru;
}
console.log(cook(&#39;大肘子&#39;));

// 4.求任意两个数的和
function getSum(num1, num2) {
    return num1 + num2;
}
console.log(getSum(1, 2));

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>return终止函数</strong></p><p>return语句之后的代码不被执行</p><p><strong>return的返回值</strong></p><p>return只能返回一个值，如果用逗号隔开多个值，以最后一个为准</p><p><strong>函数没有return返回undefined</strong></p><p>函数都是有返回值的</p><ul><li>如果有return则返回return后面的值</li><li>如果没有return则返回undefined</li></ul><p><strong>break，continue，return的区别</strong></p><ul><li>break：结束当前的循环体（如for，while）</li><li>continue：跳出本次循环，继续执行下次循环（如for，while）</li><li>return：不仅可以退出循环，还能够返回return语句中的值，同时还可以结束当前的函数体内的代码</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 函数返回值注意事项
// 1.return终止函数
    function getSum(num1, num2) {
        return num1 + num2; //return后面的代码不会被执行
        alert(&#39;我是不会被执行的！&#39;)
    }
    console.log(getSum(1, 2));
// 2.return 只能返回一个值
    function fn(num1, num2) {
        return num1, num2; //返回的结果是最后一个值
    }
    console.log(fn(1, 2));
// 3.我们求任意两个数的 加减乘除结果
    function getResult(num1, num2) {
        return [num1 + num2, num1 - num2, num1 * num2, num1 / num2];
    }
    var re = getResult(1, 2); //返回的是一个数组
    console.log(re);
// 4.我们的函数如果有return 则返回的是 return 后面的值，如果函数没有 return 则返回undefined
    function fun1() {
        return 666;
    }
    console.log(fun1); //返回666

    function fun2() {

    }
    console.log(fun2()); //函数返回的结果是undefined

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><strong>arguments的使用</strong></strong></p><blockquote><p>当我们不确定有多少个参数传递的时候，可以用arguments来获取，在JavaScript中，arguments实际上它是当前函数一个内置对象，所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参。</p></blockquote><p>arguments展示形式是一个伪数组，因此可以进行遍历，伪数组具有以下特点：</p><ul><li>具有length属性</li><li>按索引方式存储数据</li><li>不具有数组的push,pop等方法</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// arguments 的使用  只有函数才有arguments对象 而且是每个函数都内置好了这个arguments
    function fn() {
        console.log(arguments); //里面存储了所有传递过来的实参
        console.log(arguments.length);
        console.log(arguments[2]);
// 我们可以按照数组的方式遍历arguments
        for (var i = 0; i &lt; arguments.length; i++) {
            console.log(arguments[i]);
        }
    }
    fn(1, 2, 3);
// 伪数组 并不是真正意义上的数组
// 1.具有数组的length属性
// 2.按照索引的方式进行存储的
// 3.它没有真正数组的一些方法 pop()  push()等等

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>案例：利用函数判断闰年</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 利用函数判断闰年
function isRunYear(year) {
    // 如果是闰年我们返回 true 否则 返回false
    var flag = false;
    if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) {
        flag = true;
    }
    return flag;
}
console.log(isRunYear(2000));  //true
console.log(isRunYear(1999));  //false

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><strong>函数可以调用另外一个函数</strong></strong></p><p>因为每个函数都是独立代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 函数是可以相互调用的
function fn1() {
    console.log(11);
    fn2(); //在fn1函数里面调用了fn2函数
}
fn1();

function fn2() {
    console.log(22);
}   //11,22

function fn1() {
    console.log(111);
    fn2();
    console.log(&#39;fn1&#39;);
}

function fn2() {
    console.log(222);
    console.log(&#39;fn2&#39;);
}
fn1();   //111，222，fn2, fn1

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数的2种声明方式</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 函数的2种声明方式
// 1.利用函数关键字自定义函数(命名函数)
function fn() {

}
fn();
// 2.函数表达式(匿名函数)
var 变量名 = function() {}
var fun = function(aru) {
    console.log(&#39;我是函数表达式&#39;);
    console.log(aru);
}
fun(&#39;blue&#39;);
// (1)fun是变量名 不是函数名
// (2)函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值 而 函数表达式里面存的是函数
// (3)函数表达式也可以进行传递参数

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="二、回调函数-callback" tabindex="-1"><a class="header-anchor" href="#二、回调函数-callback" aria-hidden="true">#</a> <strong>二、回调函数（callback）</strong></h1><p><strong><strong>回调函数</strong></strong></p><blockquote><p>函数A作为参数(函数引用)传递到另一个函数B中，并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。</p></blockquote><h1 id="三、柯里化-curry" tabindex="-1"><a class="header-anchor" href="#三、柯里化-curry" aria-hidden="true">#</a> <strong>三、柯里化（curry）</strong></h1><p><strong><strong>什么是柯里化</strong></strong></p><blockquote><p>简单来说，就是构建一种可以实现参数部分应用的函数。直观点，一个函数需要 n 多参数，通过柯里化实现，我们可以多次调用函数每次只传部分参数，最终实现完整功能。最典型的场景是要实现一个函数，本函数的一部分参数每次都是一样的。</p></blockquote><p><strong><strong>使用场景</strong></strong></p><p>最典型的场景是要实现一个函数，本函数的一部分参数每次都是一样的。</p><p>例子一，hello world：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function hello() {
    console.log(&#39;hello world&#39;);
}

hello(); // hello world

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需求改为：say hello to anyone</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// curry
function hello() {
    return function(name) {
        console.log(&#39;hello &#39; + name);
    };
}

hello();
hello()(&#39;Allen&#39;); // hello Allen
var b = hello();
b(&#39;Bob&#39;); // hello Bob
b(&#39;John&#39;); // hello John

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需求又改为：say anyword to anyone</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// curry
function hello(word) {
    return function(name) {
        console.log(word, &#39;,&#39;, name);
    };
}

var b = hello(&#39;Hi&#39;);
b(&#39;Bob&#39;); // Hi , Bob
b(&#39;John&#39;); // Hi , John

var c = hello(&#39;Bye&#39;);
c(&#39;John&#39;); // Bye , John

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需求又改了：word + line + name</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// flexible curry !
function hello(word) {
    return function(name) {
        return function(line) {
            console.log(word, &#39;,&#39;, name, &#39;,&#39;, line);
        };
    };
}

var b = hello(&#39;Hi&#39;);
var toBob = b(&#39;Bob&#39;);
var toAllen = b(&#39;toAllen&#39;);

toBob(&#39;good day tody !&#39;); // Hi , Bob , good day tody !
toBob(&#39;Have you eaten yet ?&#39;); // Hi , Bob , Have you eaten yet ?
toAllen(&#39;get out of here !&#39;); // Hi , toAllen , get out of here !

var c = hello(&#39;Bye&#39;);
c(&#39;John&#39;)(&#39;see you tomorrow ~&#39;); // Bye , John , see you tomorrow ~

var d = hello(&#39;Hey&#39;)(&#39;Shawn&#39;);
d(&#39;this is my daily report .&#39;); // Hey , Shawn , this is my daily report .
d(&#39;this is my monthly report .&#39;); // Hey , Shawn , this is my monthly report .

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><strong>封装柯里化</strong></strong></p><p>初步封装</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 初步封装
var currying = function(fn) {
    // args 获取第一个方法内的全部参数
    var args = Array.prototype.slice.call(arguments, 1)
    return function() {
        // 将后面方法里的全部参数和args进行合并
        var newArgs = args.concat(Array.prototype.slice.call(arguments))
        // 把合并后的参数通过apply作为fn的参数并执行
        return fn.apply(this, newArgs)
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这边首先是初步封装,通过闭包把初步参数给保存下来，然后通过获取剩下的arguments进行拼接，最后执行需要currying的函数。</p><p>但是好像还有些什么缺陷，这样返回的话其实只能多扩展一个参数，currying(a)(b)(c)这样的话，貌似就不支持了（不支持多参数调用），一般这种情况都会想到使用递归再进行封装一层。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 支持多参数传递
function progressCurrying(fn, args) {

    var _this = this
    var len = fn.length;
    var args = args || [];

    return function() {
        var _args = Array.prototype.slice.call(arguments);
        Array.prototype.push.apply(args, _args);

        // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数
        if (_args.length &lt; len) {
            return progressCurrying.call(_this, fn, _args);
        }

        // 参数收集完毕，则执行fn
        return fn.apply(this, _args);
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这边其实是在初步的基础上，加上了递归的调用，只要参数个数小于最初的fn.length，就会继续执行递归。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/note/frontend/JavaScript/%E6%95%B0%E7%BB%84.html" class="" aria-label="数组"><!--[--><!--]--> 数组 <!--[--><!--]--></a></span><span class="next"><a href="/note/frontend/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F.html" class="" aria-label="作用域"><!--[--><!--]--> 作用域 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.629164ab.js" defer></script>
  </body>
</html>
