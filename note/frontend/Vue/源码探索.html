<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.53">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>源码探索 | 麦林斯的笔记</title><meta name="description" content=" ">
    <link rel="preload" href="/assets/style.e06f2840.css" as="style" /><link rel="stylesheet" href="/assets/style.e06f2840.css" />
    <link rel="modulepreload" href="/assets/app.37a6fc76.js"><link rel="modulepreload" href="/assets/源码探索.html.6924238c.js"><link rel="modulepreload" href="/assets/源码探索.html.12687c91.js"><link rel="prefetch" href="/assets/index.html.5c635ae7.js" as="script" /><link rel="prefetch" href="/assets/CSS.html.505949a5.js" as="script" /><link rel="prefetch" href="/assets/Flex.html.f9ce955c.js" as="script" /><link rel="prefetch" href="/assets/H5C3.html.192d2f5a.js" as="script" /><link rel="prefetch" href="/assets/HTML.html.b4cea3bb.js" as="script" /><link rel="prefetch" href="/assets/HTTP.html.c3fe2e38.js" as="script" /><link rel="prefetch" href="/assets/jQuery.html.bf8848ac.js" as="script" /><link rel="prefetch" href="/assets/Uni-app.html.41cd190d.js" as="script" /><link rel="prefetch" href="/assets/微信公众号.html.3d1b656d.js" as="script" /><link rel="prefetch" href="/assets/微信小程序.html.2f9dd982.js" as="script" /><link rel="prefetch" href="/assets/DOM_BOM.html.b44d8de6.js" as="script" /><link rel="prefetch" href="/assets/ES6.html.d87efb9a.js" as="script" /><link rel="prefetch" href="/assets/事件循环.html.f3a153c9.js" as="script" /><link rel="prefetch" href="/assets/作用域.html.b838662b.js" as="script" /><link rel="prefetch" href="/assets/函数.html.33a603a1.js" as="script" /><link rel="prefetch" href="/assets/函数进阶.html.bd71e450.js" as="script" /><link rel="prefetch" href="/assets/原型链.html.aa56778f.js" as="script" /><link rel="prefetch" href="/assets/对象.html.848419be.js" as="script" /><link rel="prefetch" href="/assets/常见知识点.html.7b440930.js" as="script" /><link rel="prefetch" href="/assets/异步.html.97414490.js" as="script" /><link rel="prefetch" href="/assets/数据劫持.html.29a61289.js" as="script" /><link rel="prefetch" href="/assets/数据类型.html.fd70a65b.js" as="script" /><link rel="prefetch" href="/assets/数组.html.8928426a.js" as="script" /><link rel="prefetch" href="/assets/正则.html.9296e488.js" as="script" /><link rel="prefetch" href="/assets/运算符.html.f0f67980.js" as="script" /><link rel="prefetch" href="/assets/面向对象.html.3133ae42.js" as="script" /><link rel="prefetch" href="/assets/Element-UI.html.95e79459.js" as="script" /><link rel="prefetch" href="/assets/TyprScript.html.b8770427.js" as="script" /><link rel="prefetch" href="/assets/Vue-Cli.html.746d3038.js" as="script" /><link rel="prefetch" href="/assets/Vue2.X基础.html.7ec47f93.js" as="script" /><link rel="prefetch" href="/assets/Vue3.X基础.html.42ca937a.js" as="script" /><link rel="prefetch" href="/assets/VueX.html.e26d5e55.js" as="script" /><link rel="prefetch" href="/assets/Vue路由.html.c4ef3cad.js" as="script" /><link rel="prefetch" href="/assets/Vue项目开发.html.2cb3bca5.js" as="script" /><link rel="prefetch" href="/assets/Webpack.html.ce8d9aa5.js" as="script" /><link rel="prefetch" href="/assets/生命周期.html.66726976.js" as="script" /><link rel="prefetch" href="/assets/组件通信.html.a43067eb.js" as="script" /><link rel="prefetch" href="/assets/配置开发环境.html.81034c7c.js" as="script" /><link rel="prefetch" href="/assets/404.html.c3e557d0.js" as="script" /><link rel="prefetch" href="/assets/index.html.40659dd8.js" as="script" /><link rel="prefetch" href="/assets/CSS.html.720440c6.js" as="script" /><link rel="prefetch" href="/assets/Flex.html.c5c471c8.js" as="script" /><link rel="prefetch" href="/assets/H5C3.html.e40adbdb.js" as="script" /><link rel="prefetch" href="/assets/HTML.html.d289225f.js" as="script" /><link rel="prefetch" href="/assets/HTTP.html.263ba8d3.js" as="script" /><link rel="prefetch" href="/assets/jQuery.html.7d0680d9.js" as="script" /><link rel="prefetch" href="/assets/Uni-app.html.8699a12f.js" as="script" /><link rel="prefetch" href="/assets/微信公众号.html.06d4057c.js" as="script" /><link rel="prefetch" href="/assets/微信小程序.html.63041231.js" as="script" /><link rel="prefetch" href="/assets/DOM_BOM.html.2ad2cee2.js" as="script" /><link rel="prefetch" href="/assets/ES6.html.b350bcf4.js" as="script" /><link rel="prefetch" href="/assets/事件循环.html.d738ab8a.js" as="script" /><link rel="prefetch" href="/assets/作用域.html.ed9936f5.js" as="script" /><link rel="prefetch" href="/assets/函数.html.8d859088.js" as="script" /><link rel="prefetch" href="/assets/函数进阶.html.51c59f4f.js" as="script" /><link rel="prefetch" href="/assets/原型链.html.bc4d3863.js" as="script" /><link rel="prefetch" href="/assets/对象.html.9b8e8936.js" as="script" /><link rel="prefetch" href="/assets/常见知识点.html.30aa64e0.js" as="script" /><link rel="prefetch" href="/assets/异步.html.08d294a3.js" as="script" /><link rel="prefetch" href="/assets/数据劫持.html.6cc28230.js" as="script" /><link rel="prefetch" href="/assets/数据类型.html.31d1b738.js" as="script" /><link rel="prefetch" href="/assets/数组.html.1f743a40.js" as="script" /><link rel="prefetch" href="/assets/正则.html.b4085f8e.js" as="script" /><link rel="prefetch" href="/assets/运算符.html.6b5e826e.js" as="script" /><link rel="prefetch" href="/assets/面向对象.html.01bf7ba1.js" as="script" /><link rel="prefetch" href="/assets/Element-UI.html.3a97a937.js" as="script" /><link rel="prefetch" href="/assets/TyprScript.html.972d11f4.js" as="script" /><link rel="prefetch" href="/assets/Vue-Cli.html.69c2efd6.js" as="script" /><link rel="prefetch" href="/assets/Vue2.X基础.html.344eda2d.js" as="script" /><link rel="prefetch" href="/assets/Vue3.X基础.html.f6002454.js" as="script" /><link rel="prefetch" href="/assets/VueX.html.fa2167bb.js" as="script" /><link rel="prefetch" href="/assets/Vue路由.html.36fdc0a7.js" as="script" /><link rel="prefetch" href="/assets/Vue项目开发.html.f3e7da76.js" as="script" /><link rel="prefetch" href="/assets/Webpack.html.814be314.js" as="script" /><link rel="prefetch" href="/assets/生命周期.html.c92ed3d7.js" as="script" /><link rel="prefetch" href="/assets/组件通信.html.fa4b954a.js" as="script" /><link rel="prefetch" href="/assets/配置开发环境.html.dec276ab.js" as="script" /><link rel="prefetch" href="/assets/404.html.95803d51.js" as="script" />
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">麦林斯的笔记</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/note/frontend/base/HTTP.md" class="" aria-label="前端笔记"><!--[--><!--]--> 前端笔记 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/note/frontend/base/HTTP.md" class="" aria-label="前端笔记"><!--[--><!--]--> 前端笔记 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">前端基础 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/note/frontend/base/HTTP.html" class="sidebar-item" aria-label="HTTP"><!--[--><!--]--> HTTP <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/HTML.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/CSS.html" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/H5C3.html" class="sidebar-item" aria-label="H5C3"><!--[--><!--]--> H5C3 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/Flex.html" class="sidebar-item" aria-label="Flex"><!--[--><!--]--> Flex <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/jQuery.html" class="sidebar-item" aria-label="jQuery"><!--[--><!--]--> jQuery <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html" class="sidebar-item" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/base/Uni-app.html" class="sidebar-item" aria-label="Uni-app"><!--[--><!--]--> Uni-app <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading">javaScript <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/note/frontend/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html" class="sidebar-item" aria-label="数据类型"><!--[--><!--]--> 数据类型 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E8%BF%90%E7%AE%97%E7%AC%A6.html" class="sidebar-item" aria-label="运算符"><!--[--><!--]--> 运算符 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E6%95%B0%E7%BB%84.html" class="sidebar-item" aria-label="数组"><!--[--><!--]--> 数组 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%87%BD%E6%95%B0.html" class="sidebar-item" aria-label="函数"><!--[--><!--]--> 函数 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F.html" class="sidebar-item" aria-label="作用域"><!--[--><!--]--> 作用域 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%AF%B9%E8%B1%A1.html" class="sidebar-item" aria-label="对象"><!--[--><!--]--> 对象 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE.html" class="sidebar-item" aria-label="原型链"><!--[--><!--]--> 原型链 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/DOM&amp;BOM.html" class="sidebar-item" aria-label="DOM &amp; BOM"><!--[--><!--]--> DOM &amp; BOM <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%BC%82%E6%AD%A5.html" class="sidebar-item" aria-label="异步"><!--[--><!--]--> 异步 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html" class="sidebar-item" aria-label="事件循环"><!--[--><!--]--> 事件循环 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html" class="sidebar-item" aria-label="面向对象"><!--[--><!--]--> 面向对象 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6.html" class="sidebar-item" aria-label="函数进阶"><!--[--><!--]--> 函数进阶 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E6%AD%A3%E5%88%99.html" class="sidebar-item" aria-label="正则"><!--[--><!--]--> 正则 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81.html" class="sidebar-item" aria-label="数据劫持"><!--[--><!--]--> 数据劫持 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/ES6.html" class="sidebar-item" aria-label="ES6"><!--[--><!--]--> ES6 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/JavaScript/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html" class="sidebar-item" aria-label="常见知识点"><!--[--><!--]--> 常见知识点 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">Vue <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/note/frontend/Vue/%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html" class="sidebar-item" aria-label="配置开发环境"><!--[--><!--]--> 配置开发环境 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Vue-Cli.html" class="sidebar-item" aria-label="Vue-Cli"><!--[--><!--]--> Vue-Cli <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" class="sidebar-item" aria-label="生命周期"><!--[--><!--]--> 生命周期 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html" class="sidebar-item" aria-label="组件通信"><!--[--><!--]--> 组件通信 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Vue2.X%E5%9F%BA%E7%A1%80.html" class="sidebar-item" aria-label="Vue2.X 基础"><!--[--><!--]--> Vue2.X 基础 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Vue3.X%E5%9F%BA%E7%A1%80.html" class="sidebar-item" aria-label="Vue3.X 基础"><!--[--><!--]--> Vue3.X 基础 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Vue%E8%B7%AF%E7%94%B1.html" class="sidebar-item" aria-label="Vue路由"><!--[--><!--]--> Vue路由 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/VueX.html" class="sidebar-item" aria-label="Vuex"><!--[--><!--]--> Vuex <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/note/frontend/Vue/%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="源码探索"><!--[--><!--]--> 源码探索 <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Webpack.html" class="sidebar-item" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/TyprScript.html" class="sidebar-item" aria-label="TyprScript"><!--[--><!--]--> TyprScript <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Element-UI.html" class="sidebar-item" aria-label="Element-UI"><!--[--><!--]--> Element-UI <!--[--><!--]--></a><!----></li><li><a href="/note/frontend/Vue/Vue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91.html" class="sidebar-item" aria-label="Vue项目开发"><!--[--><!--]--> Vue项目开发 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="源码探索" tabindex="-1"><a class="header-anchor" href="#源码探索" aria-hidden="true">#</a> 源码探索</h1><h1 id="vue源码探索、diff算法、双向数据绑定原理" tabindex="-1"><a class="header-anchor" href="#vue源码探索、diff算法、双向数据绑定原理" aria-hidden="true">#</a> <strong>Vue源码探索、diff算法、双向数据绑定原理</strong></h1><p><a href="https://book.penblog.cn/" target="_blank" rel="noopener noreferrer">深入剖析Vue源码<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h1 id="一、vue源码探索" tabindex="-1"><a class="header-anchor" href="#一、vue源码探索" aria-hidden="true">#</a> <strong>一、Vue源码探索</strong></h1><p><strong><strong>Diff算法</strong></strong></p><ul><li>什么是diff算法，是linux的基础命令</li><li>vdom中应用diff算法是为了找出需要更新的节点</li><li>diff算法的实现，关注patch。</li><li>核心逻辑。createElement和updateChildren</li></ul><p><strong><strong>Vue中的Diff算法</strong></strong></p><p><strong>1. 为什么要用Diff算法</strong></p><p>由于在浏览器中操作DOM的代价是非常“昂贵”的，所以才在Vue引入了Virtual DOM，Virtual DOM是对真实DOM的一种抽象描述，不懂的朋友可以自行查阅相关资料。</p><p>即使使用了Virtual DOM来进行真实DOM的渲染，在页面更新的时候，也不能全量地将整颗Virtual DOM进行渲染，而是去渲染改变的部分，这时候就需要一个计算Virtual DOM树改变部分的算法了，这个算法就是Diff算法。</p><p><strong>2. 传统的Diff算法</strong></p><p>传统的Diff算法通过循环递归对节点进行比较，然后判断每个节点的状态以及要做的操作（add，remove，change），最后 根据Virtual DOM进行DOM的渲染。大体流程如下图（图来源）：</p><p><img src="/assets/Untitled.77412cca.png" alt="Untitled"></p><p>传统Diff算法的复杂度为O(n^3)，这个复杂度相对来说还是较高的。后来React开发者提供了一种复杂度仅为O(n) 的Diff算法。下面就来看一下O(n)复杂度的Diff算法是如何实现的。</p><p><strong>3. 更高效的Diff算法</strong></p><p>React的开发者结合Web界面的特点做出了两个大胆的假设，使得Diff算法复杂度直接从O(n^3)降低到O(n)，假设如下：</p><ul><li>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；</li><li>对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</li></ul><p>通过这两个假设，他们提供了下面的Diff算法思路。</p><p><strong>同层比较</strong></p><p>新的Diff算法是逐层进行比较，只比较同一层次的节点，大大降低了复杂度，具体如下图。在后面的内容中也会介绍Vue中同层节点比较的具体实现。</p><p><img src="/assets/Untitled1.d1ca0400.png" alt="Untitled"></p><p><strong>不同类型节点的比较</strong></p><p>如果发现新旧两个节点类型不同时，Diff算法会直接删除旧的节点及其子节点并插入新的节点，这是由于前面提出的不同组件产生的DOM结构一般是不同的，所以可以不用浪费时间去比较。注意的是，删除节点意味着彻底销毁该节点，并不会将该节点去与后面的节点相比较。</p><p><strong>相同类型节点的比较</strong></p><p>若是两个节点类型相同时，Diff算法会更新节点的属性实现转换。</p><p><strong>列表节点的比较</strong></p><p>列表节点的操作一般包括添加、删除和排序，列表节点需要我们给它一个key才能进行高效的比较。</p><p><strong>4.Vue Diff算法的实现</strong></p><p>了解了Diff算法的大体思路后，我们回过头来看下Vue中的Diff算法是如何实现的。</p><p>Vue的Diff算法与上面的思路大体相似，只比较同级的节点，若找不到与新节点类型相同的节点，则插入一个新节点，若有相同类型的节点则进行节点属性的更新，最后删除新节点列表中不包含的旧节点。具体的实现在vue源码的src/core/vdom/patch.js中的updateChildren方法中，由于代码较长，下面简单说一下整个的比较流程。</p><p><strong>初始化</strong></p><p><img src="/assets/Untitled2.f4839e43.png" alt="Untitled"></p><p>如上图，有一组新旧节点数组before：[A, B, C, D]、after：[E, C, F, G]，我们设置了四个哨兵节点，oldStartIdx、newStartIdx、oldEndIdx、newEndIdx分别指向新旧节点数组的起始下标和开始下标，值为0,0,3,3；oldStartVnode，newStartVnode，oldEndVnode，newEndVnode则分别指向了before和after节点列表中对应哨兵节点下标的值，值为before[oldStartVnode],after[newStartIdx],before[oldEndIdx],after[newEndIdx]。</p><p><strong>Diff</strong></p><p>当哨兵满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx的条件的时候，我们会循环进行一系列节点之间的比较。</p><p><strong>优先判断</strong></p><p>我们首先对上面声明的各个节点进行一些优先级较高的判断。</p><p>判断1：oldStartVnode是否为空，若为true则oldStartIdx向后移动，继续下一个节点的判断。判断代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if (isUndef(oldStartVnode)) {
    // 更新哨兵
    oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>判断2：oldEndVnode是否为空，若为true则oldEndIdx向前移动。判断代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>else if (isUndef(oldEndVnode)) {
    oldEndVnode = oldCh[--oldEndIdx]
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>判断3：使用 sameVnode判断before和after未判断的头节点是否为相同节点，若为true，则按照上面思路说的，对相同类型节点进行节点的属性的更新并修改哨兵位置。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// sameVnode为判断节点是否相等的方法，包括key、tag、isComment等各个属性的相等才能算作相同节点
else if (sameVnode(oldStartVnode, newStartVnode)) {
    // 更新节点内容
    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)
    // 更新哨兵
    oldStartVnode = oldCh[++oldStartIdx]
    newStartVnode = newCh[++newStartIdx]
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>判断4：使用上一步相同的方法对oldEndVnode和newEndVnode进行判断。并执行相同的更新操作。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>else if (sameVnode(oldEndVnode, newEndVnode)) {
    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)
    // 更新哨兵
    oldEndVnode = oldCh[--oldEndIdx]
    newEndVnode = newCh[--newEndIdx]
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>判断5：使用sameVNode判断旧列表的头节点和新列表的尾节点进行判断，</p><p>sameVnode(oldStartVnode, newEndVnode)，若为true，更新相同节点，若该节点可以移动在真实DOM中将oldStartVnode，放到真实节点列表的最后。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)
    // 真实DOM移动到真实节点列表的最后面
    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
    // 更新哨兵
    oldStartVnode = oldCh[++oldStartIdx]
    newEndVnode = newCh[--newEndIdx]
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>判断6：使用sameVnode比较旧列表的尾节点和新列表的头节点，若为true，和上面一样，更新相同节点，将oldEndVnode放到真实节点列表的最开始。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)
    // 真实DOM移动到真实节点列表最前面
    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
    oldEndVnode = oldCh[--oldEndIdx]
    newStartVnode = newCh[++newStartIdx]
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这一系列的优先判断条件，一方面对于一些不需要做移动的DOM可以得到快速处理，另一方面使待处理节点变少，缩小了后续操作的处理范围，可以更快地完成同级节点的对比。</p><p>若节点不满足上面的所有判断，则会进入到最后一个条件分支，判断7：。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>else {
    // oldKeyToIdx为after列表中key和index的映射，可以加快查找速度
    if (isUndef(oldKeyToIdx)) {
        // 若不存在该映射则去初始化映射
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
    }
    // 若newStartVnode存在key的情况，则去映射中查找，若无则从oldStartIdx到oldEndIdx遍历after列表查找新节点是否存在
    idxInOld = isDef(newStartVnode.key)
        ? oldKeyToIdx[newStartVnode.key]
        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
    // 若新节点不存在于旧节点数组中，新建一个元素并插入真实DOM节点列表中
    if (isUndef(idxInOld)) { // New element
        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
    } else {
        // 若在旧列表中查找到新节点，则去判断两个节点是否相等
        vnodeToMove = oldCh[idxInOld]
        if (sameVnode(vnodeToMove, newStartVnode)) {
            // 更新节点内容和哨兵并进行节点的移动
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)
            oldCh[idxInOld] = undefined
            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
        } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        }
    }
    newStartVnode = newCh[++newStartIdx]
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>循环结束</strong></p><p>最后当oldStartIdx &gt; oldEndIdx || newStartIdx &gt; newEndIdx，也就是新或旧节点数组有一个被查找完之后则退出判断循环。当循环结束时，旧节点数组中剩下的节点即为要删除的节点，新节点数组中剩下的即为要新增的节点。只需要进行简单的新增和删除操作即可，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if (oldStartIdx &gt; oldEndIdx) {
    // 新节点数组中有剩余，新增新节点
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
} else if (newStartIdx &gt; newEndIdx) {
    // 旧节点数组中有剩余，删除旧节点
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经历过了这么多的判断之后，就完成了同级节点之间的Diff比较。</p><p><strong>就地复用</strong></p><p>在Diff中会使用到一种就地复用的策略。就地复用是指Vue会尽可能复用之前的DOM，尽可能不发生DOM的移动。</p><p>Vue判断新旧节点是否为相同节点（也就是上面的sameVnode方法），这个相同节点的意思并不是两个完全相同的节点，实际上它仅判断是否为同类节点（同类节点为类型相同且节点数据一致，如前后两个span，span标签上的属性没有改变，但是里面的内容变了，这样就算作同类节点），如果是同类节点，那么Vue会直接复用旧DOM节点，只要更新节点中的内容即可。这样可以大大减少列表中节点的移动操作。</p><p><strong>图解Diff</strong></p><p>下面通过之前的初始化的节点图，进行一步一步的图解。</p><p>（1）在初始化并设置了哨兵之后，进入了条件判断循环。第一步发现了旧数组的头和新数组的尾都是A节点，这时候进入了上面的判断5。oldStartIdx向后移动，newEndIdx向前移动。更新A节点内容并在真实DOM中将A移动到队伍最后。</p><p><img src="/assets/Untitled3.08f62dfc.png" alt="Untitled"></p><p>（2）第二次循环，进入判断7，发现新节点E并不存在于旧节点列表中，只能新建E节点，并插入真实DOM中。哨兵newStartIdx向后移动。</p><p><img src="/assets/Untitled4.7918295f.png" alt="Untitled"></p><p>（3）第三次循环，进入判断7，根据key map获取遍历旧节点数组发现C节点存在旧节点数组中，获取C节点在旧节点数组中的位置，在真实DOM中将C节点插入到oldStartNode（B节点）前面，将旧节点数组中的该元素（before[idxInOld]）置为undefined，newStartIdx向后移动。</p><p><img src="/assets/Untitled5.e5d7dc58.png" alt="Untitled"></p><p>（4）第四次循环，同第二次循环，新节点F并不存在旧节点数组中，新建F节点，并插入节点C后。newStartIdx向后移动。</p><p><img src="/assets/Untitled6.373795c0.png" alt="Untitled"></p><p>（5）newStartIdx &gt; newEndIdx，不满足循环条件，即新节点数组已处理完成。接下来进入退出循环后的条件处理，所以从oldStartIdx到oldEndIdx遍历旧节点数组，依次删除B，D两个节点。完成节点比较</p><p><img src="/assets/Untitled7.ea405cd0.png" alt="Untitled"></p><p><strong>总结</strong></p><p>Vue中的Diff算法采用了React相似的思路，都是同层节点进行比较，在比较的过程中，使用了一些优先判断和就地复用策略，提高了Diff算法的效率。</p><h1 id="二、双向数据绑定原理" tabindex="-1"><a class="header-anchor" href="#二、双向数据绑定原理" aria-hidden="true">#</a> <strong>二、双向数据绑定原理</strong></h1><p><strong><strong>学习目标</strong></strong></p><ul><li><ol><li>vue数据双向绑定的原理。</li></ol></li><li><ol start="2"><li>实现简单版vue的过程，主要实现、v-model和事件指令的功能。</li></ol></li></ul><p>相关代码地址：https://github.com/canfoo/self-vue</p><p><strong><strong>vue数据双向绑定原理</strong></strong></p><p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，我们可以先来看一下通过控制台输出一个定义在vue初始化数据上的对象是个什么东西。</p><p>代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var vm = new Vue({
  data: {
    obj: {
      a: 1
    }
  },
  created: function () {
    console.log(this.obj);
  }
});

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果：</p><p><img src="/assets/Untitled8.de44cf98.png" alt="Untitled"></p><p>我们可以看到属性a有两个相对应的get和set方法，为什么会多出这两个方法呢？因为vue是通过Object.defineProperty()来实现数据劫持的。</p><p>Object.defineProperty( )是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性get和set，如果还不熟悉其用法，请点击这里阅读更多用法。</p><p>在平常，我们很容易就可以打印出一个对象的属性数据：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var Book = {
  name: &#39;vue权威指南&#39;
};
console.log(Book.name);  // vue权威指南

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想要在执行console.log(book.name)的同时，直接给书名加个书名号，那要怎么处理呢？或者说要通过什么监听对象 Book 的属性值。这时候Object.defineProperty( )就派上用场了，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var Book = {}
var name = &#39;&#39;;
Object.defineProperty(Book, &#39;name&#39;, {
  set: function (value) {
    name = value;
    console.log(&#39;你取了一个书名叫做&#39; + value);
  },
  get: function () {
    return &#39;《&#39; + name + &#39;》&#39;
  }
})
Book.name = &#39;vue权威指南&#39;;  // 你取了一个书名叫做vue权威指南
console.log(Book.name);  // 《vue权威指南》

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们通过Object.defineProperty()设置了对象Book的name属性，对其get和set进行重写操作，顾名思义，get就是在读取name属性这个值触发的函数，set就是在设置name属性这个值触发的函数，所以当执行 Book.name = &#39;vue权威指南&#39; 这个语句时，控制台会打印出 &quot;你取了一个书名叫做vue权威指南&quot;，紧接着，当读取这个属性时，就会输出 &quot;《vue权威指南》&quot;，因为我们在get函数里面对该值做了加工了。如果这个时候我们执行下下面的语句，控制台会输出什么？</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>console.log(Book);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><p><img src="/assets/Untitled9.c0192073.png" alt="Untitled"></p><p>乍一看，是不是跟我们在上面打印vue数据长得有点类似，说明vue确实是通过这种方法来进行数据劫持的。接下来我们通过其原理来实现一个简单版的mvvm双向绑定代码。</p><p><strong><strong>思路分析</strong></strong></p><blockquote><p>实现mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据：</p></blockquote><p><img src="/assets/Untitled10.3d1140e0.png" alt="Untitled"></p><p>关键点在于data如何更新view，因为view更新data其实可以通过事件监听即可，比如input标签监听 &#39;input&#39; 事件就可以实现了。所以我们着重来分析下，当数据改变，如何更新视图的。</p><p>数据更新视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的事都好处理。如何知道数据变了，其实上文我们已经给出答案了，就是通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了。</p><p><img src="/assets/Untitled11.7b382628.png" alt="Untitled"></p><p>思路有了，接下去就是实现过程了。</p><p><strong><strong>实现过程</strong></strong></p><p>我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：</p><ul><li>1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</li><li>2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。</li><li>3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。</li></ul><p>流程图如下：</p><p><img src="/assets/Untitled12.e77078e9.png" alt="Untitled"></p><p><strong><strong>1.实现一个Observer</strong></strong></p><p>Observer是一个数据监听器，其实现核心方法就是前文所说的Object.defineProperty( )。如果要对所有属性都进行监听的话，那么可以通过递归方法遍历所有属性值，并对其进行Object.defineProperty( )处理。如下代码，实现了一个Observer。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function defineReactive(data, key, val) {
    observe(val); // 递归遍历所有子属性
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            return val;
        },
        set: function(newVal) {
            val = newVal;
            console.log(&#39;属性&#39; + key + &#39;已经被监听了，现在值为：“&#39; + newVal.toString() + &#39;”&#39;);
        }
    });
}

function observe(data) {
    if (!data || typeof data !== &#39;object&#39;) {
        return;
    }
    Object.keys(data).forEach(function(key) {
        defineReactive(data, key, data[key]);
    });
};

var library = {
    book1: {
        name: &#39;&#39;
    },
    book2: &#39;&#39;
};
observe(library);
library.book1.name = &#39;vue权威指南&#39;; // 属性name已经被监听了，现在值为：“vue权威指南”
library.book2 = &#39;没有此书籍&#39;;  // 属性book2已经被监听了，现在值为：“没有此书籍”

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>思路分析中，需要创建一个可以容纳订阅者的消息订阅器Dep，订阅器Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数。所以显然订阅器需要有一个容器，这个容器就是list，将上面的Observer稍微改造下，植入消息订阅器：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function defineReactive(data, key, val) {
    observe(val); // 递归遍历所有子属性
    var dep = new Dep();
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            if (是否需要添加订阅者) {
                dep.addSub(watcher); // 在这里添加一个订阅者
            }
            return val;
        },
        set: function(newVal) {
            if (val === newVal) {
                return;
            }
            val = newVal;
            console.log(&#39;属性&#39; + key + &#39;已经被监听了，现在值为：“&#39; + newVal.toString() + &#39;”&#39;);
            dep.notify(); // 如果数据变化，通知所有订阅者
        }
    });
}

function Dep () {
    this.subs = [];
}
Dep.prototype = {
    addSub: function(sub) {
        this.subs.push(sub);
    },
    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update();
        });
    }
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码上看，我们将订阅器Dep添加一个订阅者设计在getter里面，这是为了让Watcher初始化进行触发，因此需要判断是否要添加订阅者，至于具体设计方案，下文会详细说明的。在setter函数里面，如果数据变化，就会去通知所有订阅者，订阅者们就会去执行对应的更新的函数。到此为止，一个比较完整Observer已经实现了，接下来我们开始设计Watcher。</p><p><strong><strong>2.实现Watcher</strong></strong></p><p>订阅者Watcher在初始化的时候需要将自己添加进订阅器Dep中，那该如何添加呢？我们已经知道监听器Observer是在get函数执行了添加订阅者Wather的操作的，所以我们只要在订阅者Watcher初始化的时候触发对应的get函数去执行添加订阅者操作即可，那要如何触发get的函数，再简单不过了，只要获取对应的属性值就可以触发了，核心原因就是因为我们使用了Object.defineProperty( )进行数据监听。这里还有一个细节点需要处理，我们只要在订阅者Watcher初始化的时候才需要添加订阅者，所以需要做一个判断操作，因此可以在订阅器上做一下手脚：在Dep.target上缓存下订阅者，添加成功后再将其去掉就可以了。订阅者Watcher的实现如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function Watcher(vm, exp, cb) {
    this.cb = cb;
    this.vm = vm;
    this.exp = exp;
    this.value = this.get();  // 将自己添加到订阅器的操作
}

Watcher.prototype = {
    update: function() {
        this.run();
    },
    run: function() {
        var value = this.vm.data[this.exp];
        var oldVal = this.value;
        if (value !== oldVal) {
            this.value = value;
            this.cb.call(this.vm, value, oldVal);
        }
    },
    get: function() {
        Dep.target = this;  // 缓存自己
        var value = this.vm.data[this.exp]  // 强制执行监听器里的get函数
        Dep.target = null;  // 释放自己
        return value;
    }
};

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时候，我们需要对监听器Observer也做个稍微调整，主要是对应Watcher类原型上的get函数。需要调整地方在于defineReactive函数：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function defineReactive(data, key, val) {
    observe(val); // 递归遍历所有子属性
    var dep = new Dep();
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            if (Dep.target) {.  // 判断是否需要添加订阅者
                dep.addSub(Dep.target); // 在这里添加一个订阅者
            }
            return val;
        },
        set: function(newVal) {
            if (val === newVal) {
                return;
            }
            val = newVal;
            console.log(&#39;属性&#39; + key + &#39;已经被监听了，现在值为：“&#39; + newVal.toString() + &#39;”&#39;);
            dep.notify(); // 如果数据变化，通知所有订阅者
        }
    });
}
Dep.target = null;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此为止，简单版的Watcher设计完毕，这时候我们只要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了。因为这里没有还没有设计解析器Compile，所以对于模板数据我们都进行写死处理，假设模板上又一个节点，且id号为&#39;name&#39;，并且双向绑定的绑定的变量也为&#39;name&#39;，且是通过两个大双括号包起来（这里只是为了演示，暂时没什么用处），模板如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;body&gt;
    &lt;h1 id=&quot;name&quot;&gt;{{name}}&lt;/h1&gt;
&lt;/body&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时候我们需要将Observer和Watcher关联起来：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function SelfVue (data, el, exp) {
    this.data = data;
    observe(data);
    el.innerHTML = this.data[exp];  // 初始化模板数据的值
    new Watcher(this, exp, function (value) {
        el.innerHTML = value;
    });
    return this;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在页面上new以下SelfVue类，就可以实现数据的双向绑定了：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;body&gt;
    &lt;h1 id=&quot;name&quot;&gt;{{name}}&lt;/h1&gt;
&lt;/body&gt;
&lt;script src=&quot;js/observer.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/watcher.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var ele = document.querySelector(&#39;#name&#39;);
var selfVue = new SelfVue({
    name: &#39;hello world&#39;
}, ele, &#39;name&#39;);

window.setTimeout(function () {
    console.log(&#39;name值改变了&#39;);
    selfVue.data.name = &#39;canfoo&#39;;
}, 2000);
&lt;/script&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时候打开页面，可以看到页面刚开始显示了是&#39;hello world&#39;，过了2s后就变成&#39;canfoo&#39;了。到这里，总算大功告成一半了，但是还有一个细节问题，我们在赋值的时候是这样的形式 &#39; selfVue.data.name = &#39;canfoo&#39; &#39; 而我们理想的形式是&#39; selfVue.name = &#39;canfoo&#39; &#39;为了实现这样的形式，我们需要在new SelfVue的时候做一个代理处理，让访问selfVue的属性代理为访问selfVue.data的属性，实现原理还是使用Object.defineProperty( )对属性值再包一层：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function SelfVue (data, el, exp) {
    var self = this;
    this.data = data;

    Object.keys(data).forEach(function(key) {
        self.proxyKeys(key);  // 绑定代理属性
    });

    observe(data);
    el.innerHTML = this.data[exp];  // 初始化模板数据的值
    new Watcher(this, exp, function (value) {
        el.innerHTML = value;
    });
    return this;
}

SelfVue.prototype = {
    proxyKeys: function (key) {
        var self = this;
        Object.defineProperty(this, key, {
            enumerable: false,
            configurable: true,
            get: function proxyGetter() {
                return self.data[key];
            },
            set: function proxySetter(newVal) {
                self.data[key] = newVal;
            }
        });
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这下我们就可以直接通过&#39; selfVue.name = &#39;canfoo&#39; &#39;的形式来进行改变模板数据了。</p><p><strong><strong>3.实现Compile</strong></strong></p><p>虽然上面已经实现了一个双向数据绑定的例子，但是整个过程都没有去解析dom节点，而是直接固定某个节点进行替换数据的，所以接下来需要实现一个解析器Compile来做解析和绑定工作。解析器Compile实现步骤：</p><ul><li>1.解析模板指令，并替换模板数据，初始化视图</li><li>2.将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器</li></ul><p>为了解析模板，首先需要获取到dom元素，然后对含有dom元素上含有指令的节点进行处理，因此这个环节需要对dom操作比较频繁，所有可以先建一个fragment片段，将需要解析的dom节点存入fragment片段里再进行处理：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function nodeToFragment (el) {
    var fragment = document.createDocumentFragment();
    var child = el.firstChild;
    while (child) {
        // 将Dom元素移入fragment中
        fragment.appendChild(child);
        child = el.firstChild
    }
    return fragment;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来需要遍历各个节点，对含有相关指定的节点进行特殊处理，这里咱们先处理最简单的情况，只对带有 &#39;&#39; 这种形式的指令进行处理，先简道难嘛，后面再考虑更多指令情况：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function compileElement (el) {
    var childNodes = el.childNodes;
    var self = this;
    [].slice.call(childNodes).forEach(function(node) {
        var reg = /\{\{(.*)\}\}/;
        var text = node.textContent;

        if (self.isTextNode(node) &amp;&amp; reg.test(text)) {  // 判断是否是符合这种形式{{}}的指令
            self.compileText(node, reg.exec(text)[1]);
        }

        if (node.childNodes &amp;&amp; node.childNodes.length) {
            self.compileElement(node);  // 继续递归遍历子节点
        }
    });
},
function compileText (node, exp) {
    var self = this;
    var initText = this.vm[exp];
    updateText(node, initText);  // 将初始化的数据初始化到视图中
    new Watcher(this.vm, exp, function (value) {  // 生成订阅器并绑定更新函数
        self.updateText(node, value);
    });
},
function updateText (node, value) {
    node.textContent = typeof value == &#39;undefined&#39; ? &#39;&#39; : value;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取到最外层节点后，调用compileElement函数，对所有子节点进行判断，如果节点是文本节点且匹配这种形式指令的节点就开始进行编译处理，编译处理首先需要初始化视图数据，对应上面所说的步骤1，接下去需要生成一个并绑定更新函数的订阅器，对应上面所说的步骤2。这样就完成指令的解析、初始化、编译三个过程，一个解析器Compile也就可以正常的工作了。为了将解析器Compile与监听器Observer和订阅者Watcher关联起来，我们需要再修改一下类SelfVue函数：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function SelfVue (options) {
    var self = this;
    this.vm = this;
    this.data = options;

    Object.keys(this.data).forEach(function(key) {
        self.proxyKeys(key);
    });

    observe(this.data);
    new Compile(options, this.vm);
    return this;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更改后，我们就不要像之前通过传入固定的元素值进行双向绑定了，可以随便命名各种变量进行双向绑定了：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;{{title}}&lt;/h2&gt;
        &lt;h1&gt;{{name}}&lt;/h1&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;js/observer.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/watcher.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/compile.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var selfVue = new SelfVue({
    el: &#39;#app&#39;,
    data: {
        title: &#39;hello world&#39;,
        name: &#39;&#39;
    }
});
window.setTimeout(function () {
    selfVue.title = &#39;你好&#39;;
}, 2000);
window.setTimeout(function () {
    selfVue.name = &#39;canfoo&#39;;
}, 2500);
&lt;/script&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上代码，在页面上可观察到，刚开始titile和name分别被初始化为 &#39;hello world&#39; 和空，2s后title被替换成 &#39;你好&#39; 3s后name被替换成 &#39;canfoo&#39; 了。废话不多说，再给你们来一个这个版本的代码（v2），获取代码！</p><p>到这里，一个数据双向绑定功能已经基本完成了，接下去就是需要完善更多指令的解析编译，在哪里进行更多指令的处理呢？答案很明显，只要在上文说的compileElement函数加上对其他指令节点进行判断，然后遍历其所有属性，看是否有匹配的指令的属性，如果有的话，就对其进行解析编译。这里我们再添加一个v-model指令和事件指令的解析编译，对于这些节点我们使用函数compile进行解析处理：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function compile (node) {
    var nodeAttrs = node.attributes;
    var self = this;
    Array.prototype.forEach.call(nodeAttrs, function(attr) {
        var attrName = attr.name;
        if (self.isDirective(attrName)) {
            var exp = attr.value;
            var dir = attrName.substring(2);
            if (self.isEventDirective(dir)) {  // 事件指令
                self.compileEvent(node, self.vm, exp, dir);
            } else {  // v-model 指令
                self.compileModel(node, self.vm, exp, dir);
            }
            node.removeAttribute(attrName);
        }
    });
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的compile函数是挂载Compile原型上的，它首先遍历所有节点属性，然后再判断属性是否是指令属性，如果是的话再区分是哪种指令，再进行相应的处理，处理方法相对来说比较简单，这里就不再列出来，想要马上看阅读代码的同学可以马上点击这里获取。</p><p>最后我们在稍微改造下类SelfVue，使它更像vue的用法：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function SelfVue (options) {
    var self = this;
    this.data = options.data;
    this.methods = options.methods;

    Object.keys(this.data).forEach(function(key) {
        self.proxyKeys(key);
    });

    observe(this.data);
    new Compile(options.el, this);
    options.mounted.call(this); // 所有事情处理好后执行mounted函数
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时候我们可以来真正测试了，在页面上设置如下东西：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h2&gt;{{title}}&lt;/h2&gt;
        &lt;input v-model=&quot;name&quot;&gt;
        &lt;h1&gt;{{name}}&lt;/h1&gt;
        &lt;button v-on:click=&quot;clickMe&quot;&gt;click me!&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;js/observer.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/watcher.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/compile.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
new SelfVue({
    el: &#39;#app&#39;,
    data: {
        title: &#39;hello world&#39;,
        name: &#39;canfoo&#39;
    },
    methods: {
        clickMe: function () {
            this.title = &#39;hello world&#39;;
        }
    },
    mounted: function () {
        window.setTimeout(() =&gt; {
            this.title = &#39;你好&#39;;
        }, 1000);
    }
});
&lt;/script&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是看起来跟vue的使用方法一样，哈，真正的大功告成！想要代码，直接<a href="https://github.com/canfoo/self-vue/tree/master/v3" target="_blank" rel="noopener noreferrer">点击这里获取<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>！现象还没描述？直接上图！！！请观赏</p><p><img src="/assets/property.6a4b3c20.gif" alt="property.gif"></p><h1 id="三、vue2和vue3双向数据绑定原理的区别" tabindex="-1"><a class="header-anchor" href="#三、vue2和vue3双向数据绑定原理的区别" aria-hidden="true">#</a> <strong>三、Vue2和Vue3双向数据绑定原理的区别</strong></h1><p><strong><strong>Vue2基于Object.defineProperty</strong></strong></p><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ul><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li><li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li><li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ul><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><p><strong><strong>Vue3基于Proxy和Reflect</strong></strong></p><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p><ul><li>不需用使用 Vue.$set 或 Vue.$delete 触发响应式。</li><li>全方位的数组变化检测，消除了Vue2 无效的边界情况。</li><li>支持 Map，Set，WeakMap 和 WeakSet。</li></ul><p>Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶</p><ul><li>get 收集依赖</li><li>Set、delete 等触发依赖</li></ul><p>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</p><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p><p><strong><strong>defineProperty和proxy的区别</strong></strong></p><p>Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。</p><p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p><strong>但是这样做有以下问题：</strong></p><ul><li>添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过$set 来调用Object.defineProperty()处理。</li><li>无法监控到数组下标和长度的变化。</li></ul><p>Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于Object.defineProperty()，其有以下特点：</p><ul><li>Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li><li>Proxy 可以监听数组的变化。</li></ul><p>本文参考：<a href="https://blog.csdn.net/qq_34179086/article/details/88086427" target="_blank" rel="noopener noreferrer">Vue中的Diff算法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a><a href="https://www.cnblogs.com/canfoo/p/6891868.html" target="_blank" rel="noopener noreferrer">vue的双向绑定原理及实现<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></div><!--[--><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/note/frontend/Vue/VueX.html" class="" aria-label="Vuex"><!--[--><!--]--> Vuex <!--[--><!--]--></a></span><span class="next"><a href="/note/frontend/Vue/Webpack.html" class="" aria-label="Webpack"><!--[--><!--]--> Webpack <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.37a6fc76.js" defer></script>
  </body>
</html>
